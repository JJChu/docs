<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>计算机科学 | 光怪陆离前端</title>
    <meta name="description" content="我的前端笔记">
    <link rel="icon" href="/docs/favicons.ico">
    
    <link rel="preload" href="/docs/assets/css/0.styles.8dc399dc.css" as="style"><link rel="preload" href="/docs/assets/js/app.9c008995.js" as="script"><link rel="preload" href="/docs/assets/js/2.81827272.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.f7f35acf.js"><link rel="prefetch" href="/docs/assets/js/11.92ae7880.js"><link rel="prefetch" href="/docs/assets/js/12.39d385f8.js"><link rel="prefetch" href="/docs/assets/js/13.1b11271b.js"><link rel="prefetch" href="/docs/assets/js/14.b7339ca8.js"><link rel="prefetch" href="/docs/assets/js/15.065f816d.js"><link rel="prefetch" href="/docs/assets/js/16.c997ba0b.js"><link rel="prefetch" href="/docs/assets/js/17.cc62ae30.js"><link rel="prefetch" href="/docs/assets/js/18.f421668c.js"><link rel="prefetch" href="/docs/assets/js/19.a9804918.js"><link rel="prefetch" href="/docs/assets/js/20.02ac6e96.js"><link rel="prefetch" href="/docs/assets/js/21.62dd3c66.js"><link rel="prefetch" href="/docs/assets/js/22.85befead.js"><link rel="prefetch" href="/docs/assets/js/23.220e008c.js"><link rel="prefetch" href="/docs/assets/js/24.20500c8c.js"><link rel="prefetch" href="/docs/assets/js/25.db4f0211.js"><link rel="prefetch" href="/docs/assets/js/26.009882d5.js"><link rel="prefetch" href="/docs/assets/js/27.31e60a6b.js"><link rel="prefetch" href="/docs/assets/js/28.893b152e.js"><link rel="prefetch" href="/docs/assets/js/29.9520e734.js"><link rel="prefetch" href="/docs/assets/js/3.502c6eb9.js"><link rel="prefetch" href="/docs/assets/js/30.97ea4106.js"><link rel="prefetch" href="/docs/assets/js/31.8e64220c.js"><link rel="prefetch" href="/docs/assets/js/32.0703a7cd.js"><link rel="prefetch" href="/docs/assets/js/33.839351e2.js"><link rel="prefetch" href="/docs/assets/js/34.2b0fc04a.js"><link rel="prefetch" href="/docs/assets/js/35.47adc53e.js"><link rel="prefetch" href="/docs/assets/js/36.a7d74dd5.js"><link rel="prefetch" href="/docs/assets/js/37.b14e3927.js"><link rel="prefetch" href="/docs/assets/js/38.f7b825e8.js"><link rel="prefetch" href="/docs/assets/js/4.b73fe408.js"><link rel="prefetch" href="/docs/assets/js/5.f37bd018.js"><link rel="prefetch" href="/docs/assets/js/6.08d194e2.js"><link rel="prefetch" href="/docs/assets/js/7.97b11682.js"><link rel="prefetch" href="/docs/assets/js/8.eb55296c.js"><link rel="prefetch" href="/docs/assets/js/9.045ab69c.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.8dc399dc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">光怪陆离前端</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/fe/" class="nav-link">前端</a></div><div class="nav-item"><a href="/docs/tool/" class="nav-link">工具和库</a></div><div class="nav-item"><a href="/docs/cs/" class="nav-link router-link-exact-active router-link-active">计算机通识</a></div><div class="nav-item"><a href="/docs/note/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/docs/schedule/" class="nav-link">职业规划</a></div><div class="nav-item"><a href="https://jjchu.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  BLOG
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/fe/" class="nav-link">前端</a></div><div class="nav-item"><a href="/docs/tool/" class="nav-link">工具和库</a></div><div class="nav-item"><a href="/docs/cs/" class="nav-link router-link-exact-active router-link-active">计算机通识</a></div><div class="nav-item"><a href="/docs/note/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/docs/schedule/" class="nav-link">职业规划</a></div><div class="nav-item"><a href="https://jjchu.github.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  BLOG
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/docs/cs/" class="active sidebar-link">计算机科学</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/cs/#计算机早期历史" class="sidebar-link">计算机早期历史</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#电子计算机" class="sidebar-link">电子计算机</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#布尔逻辑和逻辑门" class="sidebar-link">布尔逻辑和逻辑门</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#二进制" class="sidebar-link">二进制</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#算数逻辑单元" class="sidebar-link">算数逻辑单元</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#寄存器-内存" class="sidebar-link">寄存器 &amp; 内存</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#cpu" class="sidebar-link">CPU</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#指令与程序" class="sidebar-link">指令与程序</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#高级-cpu-的设计" class="sidebar-link">高级 CPU 的设计</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#早期的编程方式" class="sidebar-link">早期的编程方式</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#编程语言发展史" class="sidebar-link">编程语言发展史</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#编程原理-—-语句和函数" class="sidebar-link">编程原理 — 语句和函数</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#算法入门" class="sidebar-link">算法入门</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#数据结构" class="sidebar-link">数据结构</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#阿兰·图灵" class="sidebar-link">阿兰·图灵</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#软件工程" class="sidebar-link">软件工程</a></li><li class="sidebar-sub-header"><a href="/docs/cs/#集成电路-摩尔定律" class="sidebar-link">集成电路&amp;摩尔定律</a></li></ul></li><li><a href="/docs/cs/algorithm.html" class="sidebar-link">常见算法</a></li><li><a href="/docs/cs/dataStruct.html" class="sidebar-link">数据结构</a></li><li><a href="/docs/cs/linux.html" class="sidebar-link">Linux 系统</a></li><li><a href="/docs/cs/liunx_command.html" class="sidebar-link">linux 常用命令</a></li><li><a href="/docs/cs/math.html" class="sidebar-link">数学知识</a></li><li><a href="/docs/cs/network.html" class="sidebar-link">网络</a></li><li><a href="/docs/cs/safe.html" class="sidebar-link">安全</a></li><li><a href="/docs/cs/shell.html" class="sidebar-link">Liunx Shell</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="计算机科学"><a href="#计算机科学" class="header-anchor">#</a> 计算机科学</h1> <h2 id="计算机早期历史"><a href="#计算机早期历史" class="header-anchor">#</a> 计算机早期历史</h2> <p>最早的计算机就是算盘，手动计算机，用来帮助加减数字，算盘的出现，就是因为社会规模超出了人心算的范围。后来还出现了很多计算设备，比如星盘（海上计算纬度）、计算尺（乘法和除法）等，这些设备让很费力的事情变得更快、更简单、更精确，降低了门槛，加强了我们的能力。</p> <p>最早计算机一词（computer）出现不是指工具，还是一种职业，后来才指代机器。其中最有名的是“步进计算器”（有点像汽车里的里程表），是最早可以做加减乘除运算的计算机。</p> <p>机械计算机虽然方便了计算，但有很多现实问题，依然需要很多步，而且价格昂贵。所以早之前，大部分人会用预先算好的计算表（就像一本字典，由那些 computer 编纂），还有射程表（用于战场上炮手瞄准）。但如果大炮改了设计，就需要一张新表。</p> <p>Charles Babbage 于是设计出了“差分机”（一个更复杂的机器，能近似多项式），多项式描述了几个变量之间的关系，多项式可以用于近似对数和三角函数。当时还设想了一个更复杂的机器“分析机”，分析机是通用计算机，他可以做很多事情，不只是一种特定运算，甚至可以给他数据，然后按照顺序执行一系列操作，他有内存，甚至一个很原始的打印机，最早的“自动计算机”概念，预示了计算机程序的诞生，激励了第一代计算机科学家，charles Babbage 也被称为“计算机之父”。</p> <p>19世纪末，美国人口大爆炸，人口普查变的困难。Herman Hollerith
发明了打孔卡片制表机，机器是“电动机械的”，用传统机械计数，结构类似于莱布尼茨的乘法器，但用电动接口连接其他组件，机器用打孔卡纸（一种纸片，上面有网格，用打孔来表示数据），当卡片插入机器时，小金属针会到卡片上，如果这个地方打孔了，针会穿过孔，泡入一小瓶汞，联通电路，电路驱动电机，给某一项数据 + 1。此后，这些电子机械的“商业机器”取得了巨大成功。打孔机并不是通用计算机，除了能统计数据表格外，它几乎没有别的什么用途，然而，制表机穿孔卡第一次把数据转变成二进制信息。</p> <h2 id="电子计算机"><a href="#电子计算机" class="header-anchor">#</a> 电子计算机</h2> <p>1900年中叶，全球人口爆炸和全球贸易兴起，工程和科学复杂度也达到新高，人类甚至开始考虑登录其他星球，这就有了更快的计算要求，为电子计算机的发展奠定了基础。</p> <p>最大的机电计算机之一是“哈佛马克一号”，最早的用途之一是给“曼哈顿计划”跑模拟。这台机器的大脑是继电器（用电控制的机械开关），可以做成控制电路，控制电路可以连接到其他电路，比如马达，马达让计数齿轮 + 1，但继电器因为机械臂有重量，无法达到很快的开关要求（哈佛马克一号，1 秒能做 3 次加法或减法运算，乘法 6 秒，除法 15 秒，更复杂的三角函数，可能 1 分钟以上），而且齿轮容易磨损，会损坏，需要经常维护。</p> <div class="tip custom-block"><p class="custom-block-title">BUG 由来</p> <p>这些巨大、温暖的机器容易吸引昆虫，1947 年 9 月，哈佛马克2型操作员从故障继电器中，拔出一只死虫。Grace Hopper 曾说，没当机器出现了问题，就说有了 bug，这就是 bug 的来源。</p></div> <p>1904 年，英物理学家开发了新的电子组件，“热电子管”，最早的“二极管”；1906 年。美发明家在“热电子管”的基础上，增加了“控制”电极，达到了继电器控制电路的效果，而且真空管内没有会动的组件，意味着没有磨损，而且每秒可以开关上千次，因此三级真空管成为了无线电，长途电话以及其他电子设备的基础。弱点是，跟灯泡一样，容易烧毁。这标志着计算机从机电转向电子。</p> <p>第一个大规模使用真空管的计算机是“巨人1号”，1943年。用于破解纳粹通信，巨人被称为是第一个可编程的电子计算机，虽然可编程，但是需要配置他。电子数值积分计算机（ENIAC）被建造，是世上第一个真正的通用，可编程，电子计算机，每秒可执行 5000 次十位数加减法。</p> <p>到 1950 年代，真空计算机都达到了极限。为了降低成本和大小，同时提高可靠性和速度，我们需要一个新的电子开关。1947 年，贝尔是现实科学家发明了晶体管（内含半导体），一个全新的计算机时代诞生了，他更小更快，比起真空管，他是固态，导致更小更便宜的计算机。比如 1958 年发布的 IBM 608。</p> <div class="tip custom-block"><p class="custom-block-title">硅谷</p> <p>如今计算机里的晶体管小于 50 纳米。晶体管不仅小，还超级快。每秒可以切换上百万次，并且能工作几十年。很多晶体管和半导体的开发在“圣克拉拉谷”，这个地方在加州，而生产半导体最常见的材料是“硅”，所以这个地区被称为“硅谷”。</p></div> <p>从“继电器”到”真空管“再到”晶体管“，我们可以让电路闭合得非常快，但我们如果用晶体管做计算呢？</p> <h2 id="布尔逻辑和逻辑门"><a href="#布尔逻辑和逻辑门" class="header-anchor">#</a> 布尔逻辑和逻辑门</h2> <p>早期的计算机都是机电设备，一般都用十进制计数，比如用齿轮数来代表10进制；再到了晶体管计算机，用开/关两种状态来代表信息，这叫二进制。</p> <p>可能两种状态不是很多，确实，晶体管不仅可以控制电路的开关两种状态，还可以让不同大小的电流流过，表达更多状态，早期的电子计算机有三进制，5进制的。但是状态越多，越难区分信号，如果收到周围电磁波等的影响，每秒上百万次的变化就是收到干扰。还有一个原因，有一个数学分支“布尔代数”，专门处理“真”和“假”，他已经解决了所有法则和运算，“乔治·布尔”（George Boole）是布尔二字的由来，布尔用逻辑方程系统而正式地证明真理，他在 1847 年的《逻辑的数学分析》中介绍过：在常规代数里（你在高中学的那种），变量的值是数字，可以进行加法或乘法之类的操作，但在布尔代数中，变量的值是 true 和 false，能进行逻辑操作。布尔代数中有三个基本操作，NOT，AND 和 OR。巧合的是，用晶体管我们可以轻松实现这个逻辑。</p> <div class="tip custom-block"><p class="custom-block-title">晶体管</p> <p>晶体管，是电控制的开关，有三根线：2根点击和1和控制线。控制线通电时，电流就从一个电极流到另一个电极。就像一个水龙头。
<img src="/docs/assets/img/transistor.6f11f615.png" alt></p></div> <p>可以把一个晶体管的控制线作为 input，底部的电极作为 output，input 有电流时（input on），则 output 有电流（output on）。用布尔术语来说，就是输入为 true，输入为 true；输入为 false，输出为 false。但这个电路没有什么用，因为他的输入和输出一样，但我们可以稍加修改，实现 NOT 逻辑。</p> <p>我们可以把输出放到上面，下面电极接地。如果打开输入（input on），电流可以流过然后接地，输出就没有电流了（output off）；当输入是 off，电流无法接地，就流过输出（output on）。很多，这个逻辑就和 NOT 逻辑一样了。我们称之为 NOT 门，之所以叫门，是因为它能控制电流的路径。</p> <table><thead><tr><th>input</th> <th>output</th></tr></thead> <tbody><tr><td>true</td> <td>false</td></tr> <tr><td>false</td> <td>true</td></tr></tbody></table> <p><img src="/docs/assets/img/not_gate.844c7e7a.png" alt></p> <p>AND 操作有 2 个输入，1 个输出。两个输入都为 true 时，输出才是 true，其真值表是：</p> <table><thead><tr><th>inputA</th> <th>inputA</th> <th>output</th></tr></thead> <tbody><tr><td>true</td> <td>true</td> <td>true</td></tr> <tr><td>false</td> <td>true</td> <td>false</td></tr> <tr><td>true</td> <td>false</td> <td>false</td></tr> <tr><td>false</td> <td>false</td> <td>false</td></tr></tbody></table> <p>AND 门电路是由两个晶体管串联组成。</p> <p><img src="/docs/assets/img/and_gate.9bb58e4e.png" alt></p> <p>然后是 OR 操作，也有两个输入，即两个输入只要有一个为 true，输出即为 true。其真值表是：</p> <table><thead><tr><th>inputA</th> <th>inputA</th> <th>output</th></tr></thead> <tbody><tr><td>true</td> <td>true</td> <td>true</td></tr> <tr><td>false</td> <td>true</td> <td>true</td></tr> <tr><td>true</td> <td>false</td> <td>true</td></tr> <tr><td>false</td> <td>false</td> <td>false</td></tr></tbody></table> <p>AND 门电路是由两个晶体管并联组成。</p> <p><img src="/docs/assets/img/or_gate.5ce6cd6f.png" alt></p> <p>现在三个基本电路搞定了，现在我们把他们作为一个基础组件抽象一层。业界常用下面的符号来代表这几个电路</p> <p><img src="/docs/assets/img/gate_symbol.306634a4.png" alt></p> <p>还有一个非常有用的逻辑操作叫“异或”（XOR）,XOR 很像普通的 OR,但有一个区别：两个输入都是 true 是时为 false。其真值表是：</p> <table><thead><tr><th>inputA</th> <th>inputA</th> <th>output</th></tr></thead> <tbody><tr><td>true</td> <td>true</td> <td>false</td></tr> <tr><td>false</td> <td>true</td> <td>true</td></tr> <tr><td>true</td> <td>false</td> <td>true</td></tr> <tr><td>false</td> <td>false</td> <td>false</td></tr></tbody></table> <p><img src="/docs/assets/img/xor_gate.3abe45bb.png" alt="hahha"></p> <p>XOR 门符号</p> <p><img src="/docs/assets/img/xor_gate_symbol.a18caea4.png" alt></p> <h2 id="二进制"><a href="#二进制" class="header-anchor">#</a> 二进制</h2> <ul><li>二进制的原理，二进制的加法，存储单位 MB GB TB</li> <li>正数，负数，正数，浮点数的表示</li> <li>美国信息交换标准代码 - ASCII，用来表示字符；</li> <li>unicode 1992 年诞生，是字符编码标准，解决 ASCII 不够表达所有语言的问题</li></ul> <p>对于二进制加法这里不再赘述，跟十进制一样，二进制是基于二的，逢二进一。二进制中，一个 1 或 0 叫一“位”，早期我们都是 8 位作为一个单元，8位能表示 0-255 这 256 个数字。你可能听过 8 位机，8 位图像，8 位音乐，意思就是计算机里大部分操作都是 8 位 8 位这样处理的。</p> <p>8 位如此常见，以至于有专门的名字：字节。后来衍生出了很多量级，换算单位如下：</p> <ul><li>1B(Byte 字节)=8bit</li> <li>1KB (Kilobyte 千字节)=1024B</li> <li>1MB (Megabyte 兆字节 简称“兆”)=1024KB</li> <li>1GB (Gigabyte 吉字节 又称“千兆”)=1024MB</li> <li>1TB (Trillionbyte 万亿字节 太字节)=1024GB，其中1024=2^10 ( 2 的10次方)</li> <li>...</li></ul> <p>现在的电脑可能都是 32 位或者 64 位的，意思是一块块处理数据，每块是 32 为或 64 位。</p> <p>当然，不是所有的数字都是正数，还有负数。我们需要有方法去表示正数和负数，大部分计算机的第一位表示正负，1 为负，0 为正。用剩下的 31 位去表示数字，大概范围是正 20 亿到负 20 亿。虽然数字很大，但有时候还是不够用，所以 64 位就很有用了。计算机必须给内存中的每一个位置，做一个标记，叫做“位址”，目的是为了方便存储数据。</p> <p>出了表示整数，我们还要表示小数，又叫浮点数（因为小数点可以在数字间浮动）。有好几种方法表示浮点数，常见的是 IEEE 754 标准，他用类似科学计数法的方法，来存十进制值。</p> <p>比如：625.9，用科学计数法是 0.6259 * 10^3，其中 .6259 叫“有效位数”，3 是指数。在 32 位浮点数中，第 1 位表示正负，接下来的 8 位存指数，剩下的 23 为存有效数字。</p> <p>好了，说完数字，我们来说文字是如何表达的，计算机也是用数字来表达字母的，最直接的方式就是给字母编号。ASCII（美国信息交换标准代码），发明于 1963 年，是 7 位的代码，足够存 128 个不同值：可以表示大写字母，小写字母数字 0-9 以及一些符号。ASCII 是很早的标准，所以被广泛运用，让不同公司制作的计算机，能相互交换数据，这种通用交换信息的能力叫“互用性”，担忧个限制，他是为英语设计的。幸运的是，1 个字节有 8 位，后面的数字逐渐也被使用，这些字符以前是空的，是给各个国家自己“保留使用的”，这些保留位置对大部分国家够用了，但对于中文、日文等就远远不够了。因此很多国家发明了自己的编码方案，但不相互兼容，早之前我们会经常出现乱码问题（mojibake）。</p> <p>所以 unicode 诞生了，统一了所有的编码标准，设计与 1992 年，解决了不同标准的问题。unicode 用一个统一的编码标准，常见的 unicode 是 16 位的，有超过一百万个位置，对所有语言的每个字符都够了，100 多种字母表加起来占了 12 万个位置，还有位置放数学符号，甚至 Emoji。</p> <p>就是 ASCII 用数字编码文字一样，用二进制编码声音/颜色，表示照片，电影，音乐，重要的是，这些标准归根结底是一长串位。</p> <h2 id="算数逻辑单元"><a href="#算数逻辑单元" class="header-anchor">#</a> 算数逻辑单元</h2> <ul><li>简单介绍 ALU；</li> <li>ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元</li> <li>算术单元：半加器和全加器</li> <li>逻辑单元：检测数字是否为 0 的电路...</li></ul> <p>我们知道了计算机如何表示数字，但真正的目标是计算和有意义的处理数字，这些操作就是由计算机的”算术逻辑单元“处理，简称 ALU（Arithmetic &amp; Logic Unit）。ALU 是计算机的数学大脑，是现代计算机的基石。ALU 是计算机里负责运算的组件，基本其他所有部件都用到了它。</p> <p>ALU 有 2 个单元，1 个算术单元和 1 个逻辑单元，算术单元负责计算机里的所有数字操作（加减法、增量运算）。我们用上面提到的逻辑电路来完成一个加法电路。</p> <p>最简单的加法电路，是拿 2 个 bit 加在一起（bit 是 0 或 1），有两个输入：A 和 B，1 个输出：他们的和。需要注意：A B 输出这 3 个都是单个 bit（0 或 1）。输出有 4 中可能，前三个是 <code>0 + 0 = 0</code>，<code>1 + 0 = 1</code>，<code>0 + 1 = 1</code>。 我们会发现，这组输入输出，和 XOR 门的逻辑完全一样，我们可以把 XOR 用作 1 位加法器（adder）。第四组输入组合，1 + 1，是个特例，显然 1 + 1 = 2，但二进制没有 2，所以结果应该是 0，1 进到下一位，和是 10（二进制）。所以 XOR 门的输出，只对了一部分，我们还需要一根额外的线代表”进位“，只有输入 1 和 1 是，进位才是 &quot;true&quot;，显然，AND 门满足这个条件。我们把它加入到电路，就形成了一个”半加器“电路。</p> <p><img src="/docs/assets/img/half_adder.e1d2ed63.png" alt></p> <p>现在我们抽象一层，把”半加器“封装成一个单独组件：2 个输入 A 和 B，都是 1 位；2 个输出：总和与进位</p> <p><img src="/docs/assets/img/half_adder_zj.e8dd8e4d.png" alt></p> <p>如果想出来超过 1 + 1 的计算，我们需要”全加器“，半加器输出了进位，以为着我们之后的每一列，我们得 3 个位在一起。全加器有 3 个输入：A B C（都是 1 个 bit），两条输出线：总和和进位。我们可以用半加器做全加器，我们也可以把他抽象成一个组件。</p> <p><img src="/docs/assets/img/full_adder.703d0ba9.png" alt></p> <p>我们可以组装一个八位加法器。最低位输入只有 A 和 B，所以是一个半加器；之后的高位有可能有进位，所以全加器。最有一个如果还有进位，超过了 8 位，说明溢出了。ALU 的算术单元，也能做一些其他数学运算：加法、带进位加法、减法、带借位的减法、Negate、增量、减量、数字无法通过，对于乘法和除法，很多简单的处理器是通过多次加法和减法处理的。当然，现代一些高级处理器有自己的乘法电路，也更复杂。</p> <p><img src="/docs/assets/img/8_bit_adder.d247bb77.png" alt></p> <div class="tip custom-block"><p class="custom-block-title">溢出</p> <p>溢出是指两个数字之和太大，超出了可以表示的位数，这会导致错误和不可预期的结果。想避免溢出，我们就需要增加更多全加器，操作 16 位或 32 位数字，可以表达更大的数字，但需要增加更多电路，另外一个缺点，每次进位都需要时间，虽然电子移动很快，但大量级的运算下，还是会造成影响。所以，现代计算机用的加法器有点不同，叫”超前进位加法器“。</p></div> <p>现在来说 ALU 的另一半：逻辑单元，逻辑单元进行逻辑操作，比如之前讨论的 AND、OR 和 NOT 操作，他能做一些简单的数值测试。比如这个检测 ALU 输出是否为 0 的电路，是由一堆 OR 门电路组成的：</p> <p><img src="/docs/assets/img/is_zero.2d43badc.png" alt></p> <p>复杂 ALU 中的电路会更加复杂，工程师们在使用 ALU 时不想去想那些事情，所以想了一个特殊的符号来代表他（大 “V”），又一次抽象，我们 的 8 位 ALU 有两个输出，A 和 B，都是 8 位（bits），我们还需要告诉 ALU 执行什么操作，比如加法或加法，通常我们用 4 位操作代码，”1000“ 可能代表加法命令，1100 代表减法命令。 ALU 还会输出一堆标志（Flag），标志是一位的，代表特定状态，高级 ALU 会有很多标志，但通常有这几个：ZERO（结果是否为 0）、OVERFLOW（是否溢出）、NEGATIVE（结果是否为负）。</p> <p><img src="data:image/png;base64,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" alt></p> <h2 id="寄存器-内存"><a href="#寄存器-内存" class="header-anchor">#</a> 寄存器 &amp; 内存</h2> <p>如何存储计算结果，我们就要用到计算机内存。比如，你在电脑上玩扫雷，有人不小心拔掉了电源，你将会失去进度，你损失数据的原因是电脑用的是”随机存取储存器“，简称”RAM“（Random Access Memory），它只能在有电的情况下存储东西。另一种存储方式也叫持久存储，电源关闭也不会丢失。我们先从简单的开始，做一个存储 1 位的电路，之后扩大，做出内存模块，之后再和 ALU 结合起来，就能做出一个 CUP。</p> <p>我们目前说过的电路都是单向的，总是向前流动，但也可以做回向电路，把输出连回输入会发生什么事情呢？</p> <p>先拿 OR 门试一下，当两个输出都为 0 时，没什么变化；当把输出 A 改为 1 时，输出为 1，通过回路输入 B 也为 1；再把 A 变成 0，输出仍然为 1；现在我们有个电路能够记录 1 了，我们能通过 A 来永久存储一个 1，但有个问题，它是永久的。</p> <p><img src="/docs/assets/img/or_gate_circle.b9794655.png" alt></p> <p>我们再换成 AND 门看看会怎么样？刚开始，两个输入都为 1，输出为 1；当 A 变为 0 时，输出为 0。这个电路能存储 0。无论 A 设什么值，电路始终输出 0。</p> <p><img src="/docs/assets/img/and_gate_circle.cbab7f3e.png" alt></p> <p>为了做出有用的存储，我们把两个电路结合起来，叫 ”AND-OR 锁存器“。他有两个输入，SET（设置）把输出变为 1，RESET（复位）把输出变为 0；如果 SET 和 RESET 都是 0，电路会输出最后放入的内容。也就是说，他存住了 1 位的信息，这叫”锁存“，因为它”锁定“了一个值：放入数据的动作叫”写入“，拿出数据的动作叫”读取“。</p> <p><img src="/docs/assets/img/and_or_latch.67f1df2d.png" alt></p> <p>但用两条线来输入，有点难以理解，为了更容易用，我们希望只有一条输入线，将他设为 0 和 1 存储，还需要一根线来”启用“内存（启用时允许写入，没启用时就锁定），叫”允许写入线“。加入一些电路，我们就可以实现了，这个叫”门锁“。</p> <p><img src="/docs/assets/img/gated_latch.fa54ce15.png" alt></p> <p>我们不想关心独立的逻辑门，所以我们提升一层抽象，把这个门锁作为一个独立组件，这个组件能存储 1 位的信息。一组这样的锁存器叫”寄存器“，寄存器能存一个数字，这个数字有多少位，叫”位宽“。早期计算机用 8 位寄存器，现在我们有 32 位宽，64位宽的。</p> <p><img src="/docs/assets/img/gated_latch_zujian.b7276851.png" alt></p> <p>写入寄存器前，要先启用里面所有锁存器，我们用 1 根线链接所有锁存器”允许写入线“来控制，然后用 8 条数据线发数据。这样我们就能存储 8 位的值了。</p> <p><img src="/docs/assets/img/8_bit_register.403a02e5.png" alt></p> <p>位数很少时，把锁存器并排放置，也勉强够用，64 位的寄存器需要 64 根数据线，64 根连到输出端，1 根启用所有锁存器的线，加起来也有 129 根线，如果存 256 为要 513 条线。解决方案就是矩阵。</p> <p>在矩阵中，我们并不并列排放锁存器，而是做成网格，比如，存 256 位，我们用 16 ✖ 16 网格的锁存器，要启用某个锁存器，就打开相应的行线和列线。</p> <p><img src="/docs/assets/img/latch_matrix_16x16.536ee730.png" alt></p> <p>我们看其内部细节，我们用一个 AND 门链接行线、列线来控制”允许写入线“。我们每次只启用一个锁存器，代表我们可以只用一根数据线链接所有锁存器来传数据；同样，我们也可以用相同的技巧来做”允许读取线“，从一个指定的锁存器中，读取数据。所以，对于 256 位的存储，只要 35 根线（1条数据线，1条允许写入线，1条允许读取线，还有 16行16列的线用于选择锁存器）</p> <p><img src="/docs/assets/img/latch_matrix_detail.d85c59ae.png" alt></p> <p>现在我们需要一种方法来在矩阵中唯一指定”交叉路口“，即交叉口的地址，比如 12行 8 列，因为最多 16 行 16 列，我们用 4 位就可以了。12 用二进制表示为 1100，列地址 8 用二进制表示为 1000，所以”12 行 8“列可以写成 11001000。</p> <p>为了将地址转成行和列，我们需要”多路复用器“，多路复用器有不同大小。因为有 16 行，我们需要 1 到 16 多路复用器。工作方式是：输入一个 4 位数字，它会把那根线，连到相应的输出线，一个多路复用器处理行，一个处理列。现在我们把 256 为内存当做一个整体，做一次抽象。它输入一个 8 位地址，8 个”地址线“，还需要”允许写入线“和”允许读取线“，最后，需要一条数据线，用于读、写数据。</p> <p><img src="/docs/assets/img/multiplexer.4683bd78.png" alt></p> <p>但用一个 256 位内存也没能做什么事，所以我们要扩大规模，我们用 8 个 256 内存并排放置，就像寄存器，这样我们就可以存一个 8 位数字（1个字节 byte）。在存一个 8 位数字时，我们同时给 8 个 256 内存一样的地址，每个地址存 1 位，意味着我们这里一共可以存 256 个字节。</p> <p><img src="/docs/assets/img/momery_8x256.f1930c62.png" alt></p> <p>再次，我们不管内部，做一次抽象。把他看做一个整体的可寻址内存，我们将有 256 个地址，每个地址能读写 1 个 8 位值。我们做 CPU 时将会用到这个内存。现代计算机的内存可以做到很大，但原理和这里一样，只不过是不断把内存打包到更大规模。</p> <p><img src="/docs/assets/img/ram_8x256.3d9b93cd.png" alt></p> <p>随着内存增多，内存地址也在增长，8 位最多能代表 256 个内存地址，要给千兆或十亿字节的内存寻址，那就需要 32 位的地址，内存的一个重要特性：可以随时访问任何位置。因此也叫”随机存取存储器“，简称 RAM（Random Access Memory），RAM 就像人的短期记忆，记录当前在做什么事。现在，我们用锁存器做了一块 SRAM（静态随机存取储存器），还有其他类型，如 DRAM，闪存和 NVRAM。他们功能上相似，但用不同的电路存单个位，比如不同的逻辑门，电容器，电荷捕获或忆阻器，但根本上，这些技术都是矩阵层层嵌套，来存储大量信息。</p> <p><img src="/docs/assets/img/ram.bc86c5e4.png" alt></p> <h2 id="cpu"><a href="#cpu" class="header-anchor">#</a> CPU</h2> <p>现在我们已经做出了 ALU（算术逻辑单元，输入二进制，它会进行计算）。还有两种存储单元，寄存机（很小的内存，只能存一个值），和 RAM（是一块很大的内存，能在不同的地址存大量数字），把这些组装起来，就可以组装成计算机的“心脏”中央处理器，简称CPU（Central Processing Unit）。</p> <p>CPU 负责执行程序，比如 office，Safari，还有游戏等等。程序是由一个个操作组成，叫做“指令”（Instruction）。如果是数学指令（加减乘除），CPU 会让 ALU 进行数学计算；也可能是内存指令，CPU 会和内存通信，然后读/写值。</p> <p>CPU 中有很多组件，我们这里着重于它的功能，不涉及具体的线怎么连。当我们用一根线链接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次的视角叫做“微体系架构”。</p> <p>首先我们需要一个 RAM 来存储数据，再来四个寄存器用来临时存数据和操作数据。数据都是以二进制的形式存储，程序也可以。我们可以给 CPU 支持的所有指令分配一个 ID。在这个假设的例子中，我们用前四位存“操作代码”（operation code），简称操作码（opcode），后四位代表数据来自哪里，可以是寄存器或者内存地址。</p> <p><img src="/docs/assets/img/instruction.a2a4a0f9.png" alt></p> <p>我们还需要两个寄存器，来完成 CPU，一个用来追踪程序运行到哪里了，我们叫它“指令地址寄存器”，存当前指令的内存地址；另一个寄存器存当前指令，叫“指令寄存器”。</p> <p>当计算机启动时，所有寄存器从 0 开始，为了举例，我们首先在 RAM 里放一个程序。CPU 的第一个阶段是“取指令阶段”，首先，将“指令地址寄存器”连接到 RAM，寄存器的值为 0，所以返回地址 0 的值，因此 0010 1110 会复制到“指令寄存器”里；第二个阶段是“解码阶段”，我们要弄清楚这个是什么指令，前四位 0010 是 LOAD A 指令，意思是把 RAM 的值放入寄存器 A，后四位 1110 是 RAM 的地址，转成十进制是 14。接下来，指令由“控制单元”进行解码，就如之前的一样，控制单元也是由逻辑门组成的，比如，为了识别 “LOAD A” 指令。需要一个电路，检查操作码是不是 0010，知道了是什么指令，就可以开始“执行阶段”，用“检测是否是 LOAD A 执行的电路”可以打开 RAM 的“允许读取线”，把地址 14 传过去，RAM 拿到值 0000 0011，十进制的 3，因为是 LOAD_A 指令，我们想把这个值只放到寄存器 A，其他寄存器不受影响，所以需要一根线把 RAM 连接到 4 个寄存器，用“检查是否是 LOAD_A 指令的电路”，启用寄存器 A 的“允许写入线”，这就成功了，把 RAM 14 的值，放到了寄存器 A。既然指令完成了，我们可以关闭掉所有电路，去哪下一条指令。我们把“指令地址寄存器”+1，“执行阶段就此结束”。</p> <p><img src="/docs/assets/img/LOAD_A.2860bbc1.png" alt></p> <p>LOAD_A 指令只是 CPU 可以执行的各种指令之一，不同的指令由不同的逻辑电路解码，这些逻辑电路会配置 CPU 内的组件来执行对应的操作，具体分析这些解码电路太繁琐了，既然已经看过一个例子，干脆把“控制单元”包成一个整体，没错，又是一层抽象。控制单元就像是管弦乐队的指挥，指挥 CPU 的组件“取指令 -&gt; 解码 -&gt; 执行“。同样的流程，执行 LOAD_B 指令，将 RAM 中的值复制到寄存器 B 中，最后“指令地址寄存器”+1。</p> <p>后面一个指令有点特殊，是 ADD 执行，这次后面四位不再是 RAM 地址，而是两位两位分别带代表 2 个寄存器，2 位可以表示 4个值，刚好可以代表四个寄存器。因此 1000 0100 代表把寄存器 B（01）中的值加到寄存器 A（00）中，要执行这个指定，我们要整合 ALU 进来。控制单元负责选择正确的寄存器作为输入，并配置 ALU 执行正确的操作。对于 ADD 指令，”控制单元“会启用寄存器 B 作为第一个出入，还启用 A 作为第二个输入，之前说过，ALU 可以执行不同的操作，所以控制单元必须传递 ADD 操作码告诉它要做什么，最后，结果应该存到寄存器 A，但不能直接写入 A，因为新值会进入 ALU，不断和自己相加，所以控制单元用自己的寄存器暂时保存，关闭 ALU，然后把值写入正确的寄存器。最后把指令地址+1。</p> <p><img src="/docs/assets/img/ADD.c47a5bc2.png" alt></p> <p>最后一个指令是 STORY A，解码得知是把寄存器 A 中的值放入内存 RAM，地址是 13。接下来，把地址传给 RAM，但这次不是允许读取，而是允许写入，同时，打开寄存器 A 的允许读取，这样就可以把寄存器 A中的值传给 RAM。终于，我们完成了一个程序。</p> <p>我们现在是一步一步去拆解的，但在 CPU 中，是靠”时钟“来负责管理 CPU 的节奏。时钟以精准的间隔，触发电信号，控制单元会用这个信号，推进 CPU 内部操作，确保一切按步骤进行，就像划龙舟上的锣鼓手，让所有划船人同步，就像节拍器一样。节奏不能太快，因为就算是点也需要一定的时间来传输。</p> <p>CPU ”取指令 -&gt; 解码 -&gt; 执行“的速度叫做”时钟速度“，单位是赫兹，1 赫兹代表 1 秒一个周期。如今的处理器很强大，能达到几千兆赫兹，相当于 1 秒 10 亿次时钟周期。有些人会把自己的 CPU 调整超频，因为 CPU 厂商通常会留一点余地，可以接受一点超频。但如果超频过大，就会使 CPU 过热或者乱码，因为信号跟不上时钟。当然还有降频，在跑一个性能要求很低的软件或者息屏时，把 CPU 频率降下来，会省很多电。现在很多处理器可以按需求加快或降低速度，这叫”动态调整频率“。加上时钟后，CPU 才是完整的。</p> <p><img src="/docs/assets/img/CPU_CHIP.1ebdaa5d.png" alt></p> <h2 id="指令与程序"><a href="#指令与程序" class="header-anchor">#</a> 指令与程序</h2> <p>CPU 之所以强大，是因为它是可编程的，如果写入不同的指令，就会执行不同的任务。CPU 是一个硬件，可以被软件控制。</p> <p>上一节我们用四个指令完成了一个加法程序，现在我们多增加一些指令吧。SUB 减法指令，和 ADD 一样需要两个寄存器来工作。还有 JUMP 指令，让程序跳转到新位置，如果想改变指令顺序，或跳过一些指令，这个很实用。比如，JUMP 0 是跳转到指令的开头，JUMP 在低层的实现方式是把指令后 4 位代表的内存地址的值覆盖掉”指令地址寄存器“里的值。还有一个特别版的 JUMP 叫 JUMP NEGATIVE，它只在 ALU 的”负数标志“为真时，进行 JUMP。最后，计算机还需要知道什么时候停下来，所以有 HALF 指令（停止）。我们之前的例子中，执行完 STORY A 之后，会继续执行后面的 0，但 0 并不是操作码，所以电脑会崩溃，还有一点，指令和数据都是存在同一个内存里的，他们在根本上毫无区别，都是二进制数。</p> <p>针对之前的例子，我们在 STORY 指令执行完之后，在后面补充一个 JUMP 2 执行，那么一个程序就会一直累加下去，这叫无限循环。为了停下来，我们需要有条件的 JUMP，只有特定条件满足了，才执行 JUMP，比如 JUMP NEGATIVE 就是条件跳转的一个例子，还有其他类型的条件跳转，比如 JUMP IF EQUAL（如果相等）JUMP IF GREATER（如果更大）。</p> <p>用这几个指令实现一个简单的求余程序？？</p> <p><img src="/docs/assets/img/rem_instruction.103ff838.png" alt></p> <p>这就是软件（程序）的强大之处，软件还让我们做到硬件做不到的事，ALU 没有除法功能，是程序给了我们这个功能，别的程序也可以用我们的除法程序，来做其他的事情。这意味着一层新抽象。</p> <p>我们前面的例子所有的指令都是 8 位，前面 4 位代表操作码，这样最多也就只能表示 16 个指令，我们有几条指令是用后面的 4 位代表内存值，最多也就表示 16 个位置，这可不多。所以真正的现代 CPU 用两种策略。</p> <p>一种是直接用更多的位来代表指令，比如 32 位或 64 位，这叫“指令长度”。另一种策略是“可变指令长度”，比如，某个 CPU 用 8 位长度的操作码，如果看到 HALF 指令，HALF 不需要额外数据，所以马上停止；如果看到 JUMP，它得知道位置，这个值在 JUMP 的后面，这叫“立即值”，这样设计，指令可以是任意长度，但会让读取阶段复杂一点点。要说明的是，我们用来举例的 CPU 和指令集都是假设的，是为了展示核心原理。现在我们来看看真正的 CPU 的例子。</p> <p>1971 年，英特尔发布了 4004 处理器，这是第一次把 CPU 做成一个芯片，给后来的英特尔处理器打下基础。</p> <p><img src="/docs/assets/img/CPU_4004.5cd73f33.png" alt></p> <p>他用了我们说过的很多指令，也用 8 位的“立即值”来执行 JUMP，以表示很多的内存地址。</p> <p><img src="/docs/assets/img/4004_instruction.fa308f7b.png" alt></p> <p>处理器从 1971 年到现在发展巨大，现在 CPU， 如英特尔酷睿 i7，有上千条指令和指令变种，长度从 1 到 15 个字节，举例，光 ADD 指令就有很多变种！指令越来越多，是因为给 CPU 设计了越来越多的功能。</p> <h2 id="高级-cpu-的设计"><a href="#高级-cpu-的设计" class="header-anchor">#</a> 高级 CPU 的设计</h2> <p>我们知道计算机的发展速度巨大，从 1 秒 1 次的计算，到现在有千赫甚至兆赫的 CPU。</p> <p>早期计算机的提速方式是，减少晶体管的切换时间。晶体管组成了逻辑门，ALU 以及前面说的其他组件，但这种方式最终会碰到瓶颈。所以处理器厂商发明各种新技术来提升性能，不但让简单指令运行更快，也能让它进行更复杂的运算。</p> <p>上节我们做了个除法的程序，是利用一连串减法来实现的，但这种方式需要多个时钟周期，十分低效。所以现代 CPU 直接在硬件层面设计了除法，可以直接给 ALU 除法指令。这让 ALU 更大也更大复杂，但也更厉害，复杂度 VS 速度的平衡在计算机发展史上经常出现。现代处理器有专门的电路处理图形操作，解码压缩视频，加密文档等等，你可能听说过某些处理器有 MMX、3DNOW、SEE，他们有额外的电路处理更复杂的操作，用于游戏和加密等场景。</p> <p>超高的时钟速度带来另一个问题，如何快速传递数据给 CPU，就像有强大的蒸汽机，但不能快速加煤，RAM 成为了瓶颈。RAM 是 CPU 之外的独立组件，以为着数据要用线来传递，叫“总线”（BUS）。虽然电的传输速度很快，大 CPU 每秒可以处理上亿条指令，很小的延迟也会造成问题，RAM 还需要时间找地址，取数据，配置，输出数据，一条“从内存读数据”的指令可能要多个时钟周期，CPU 空等数据。解决延迟的方法之一是给 CPU 加一点 RAM — 叫“缓存”（CACHE）。</p> <p><img src="/docs/assets/img/CPU_CACHE.365e8dd7.png" alt></p> <p>因为处理器里空间不大，所以缓存一般只有 KB 或 MB，而 RAM 都是以 GB 起步的。缓存提高了速度，CPU 从 RAM 拿数据时，RAM 不用传一个，可以传一批，虽然花的时间多点，但数据可以存在缓存中。这非常有用，因为数据通常是一个个按顺序处理。举例：算餐厅的当日收入，先去 RAM 地址 100 的交易额，RAM 与其只给一个值，直接给一批值，把地址 100-200 都复制到缓存，当 CPU 要下一个交易额时，地址 101，缓存会说：“我已经有了，现在就给你”。不用去 RAM 取数据。因为缓存离 CPU 近，一个时钟周期就能给数据，CPU 不用空等。如果想要的数据已经在缓存，叫缓存命中（CACHE HIT），不在的话，叫缓存未命中（CACHE MISS）。缓存也可以当临时空间，存一些中间值，适合长/复杂的运算。继续餐馆的例子，加入 CPU 算完了一天的限售额，想把地址存到地址 150，就像之前，数据不是直接存到 RAM，而是存在缓存，这样不但存起来快一些，而且如果还要接着算，取值也快一些，但这样带来一个有趣的问题，缓存和 RAM 不一致了，这种不一致必须记录下来，之后要同步，因此缓存里的每块空间，都有一个特殊标记，叫“脏位”（DIRTY BIT）— 这可能是计算机科学家取的最贴切的名字。同步一般发生在当缓存满了而 CPU 又要缓存时。在清理缓存腾出空间之前，会先检查“脏位”，如果是脏的，在加载新内容之前，会把书局写回 RAM。</p> <p>另一种提升性能的方法是”指令流水线“（Instruction Pipelining）。现象一下你要洗一整个酒店的床单，只有一个洗衣机和一个干燥机。选择1：按顺序来，放洗衣机等 30 分钟洗完后，再放入干燥机等 30 分钟烘干，这样 1 小时洗一批。其实我们可以通过”并行处理“（Parallelize）来提高效率：就像之前，我们可以在干燥的时候，洗衣机直接洗下一批衣服，不必干等 30 分钟，两台机器同时工作，效率翻倍。</p> <p><img src="/docs/assets/img/parallelize.0d87878f.png" alt></p> <p>处理器也可以这样设计，我们之前演示 CPU 的按序处理，”取指令 —&gt; 解码 -&gt; 执行”，不断重复。这种设计，三个时钟周期执行 1 条指令。</p> <p><img src="/docs/assets/img/order_exec.266b3801.png" alt></p> <p>但因为每个阶段用的是 CPU 中不同的部分，意味着可以并行处理。执行一个指令时，可以解码另一个指令，取下下个指令，这样的流水线，每个时钟周期执行 1 个指令，吞吐量✖️3。</p> <p><img src="/docs/assets/img/paralle_exec.a414c628.png" alt></p> <p>和缓存一样，也会有一些问题，第一个问题是指令之间的依赖关系，比如，你在读取某个数据，而正在执行的指令会改这个数据。因此流水线处理器，要先弄清数据的依赖性，必要时停止流水线，防止出问题。高端 CPU，比如笔记本和手机里的会更进一步，动态排序有依赖关系的指令，最小化流水线的停工时间，这叫“乱序执行”（out-of-order execution），这种电路十分复杂，但因为十分高效，几乎所有的现代处理器都有流水线。第二个问题是“条件跳转”，这些指令会改变程序的执行流，简单的流水线处理器，看到 JUMP 指令会停一会儿，等条件值确定下来，一旦 JUMP 的结果出了，处理器就继续流水线。因为空等会造成延迟，所以高端处理器会用一些技巧，可以把 JUMP 想成是“岔路口”，高端 CPU 会猜测那条路的可能性大一些，然后提前把指令放入流水线，这叫“推测执行”。当 JUMP 结果出了，如果 CPU 猜对了，流水线已经塞满正确指令，可以马上运行，如果猜错了，就要清空流水线。为了尽可能减少清空流水线的次数，CPU 厂商开发了复杂的方法来猜测哪条分支更有可能，叫“分支预测”（Branch Prediction），现代 CPU 的正确率超过了 90%。正常情况下，流水线一个周期完成 1 个指令，然后“超标量处理器”（Superscalar）出现了，一个时钟周期完成多个指令，即使有流水线设计，在指令执行阶段，处理器里有些区域还是可能会空闲，比如，执行一个“从内存中取值”指令期间，ALU 会闲置。所以，一次性处理多条指令（取指令 + 解码）会更好，如果多条指令要 ALU 的不同部分，就多条同时执行，我们可以再进一步，多加几个相同的电路，执行出现频次很高的指令。举例，很多 CPU 有四个、八个甚至更多完全相同的 ALU，可以同时执行多个数学运算。</p> <p>好了，目前说过的方法，都是优化一个指令流的吞吐量，另一个提升性能的方法是：同事运行多个指令流，用多核处理器，意思是一个 CPU 芯片里，有多个独立处理单元，很像有多个 CPU，但因为他们整合紧密，可以共享一些资源，比如缓存，使得多核可以合作运算。但多核不够时，可以用多个 CPU，截止 2016 年，世上最快的计算机在中国无锡国家超算中心，神威·太湖之光有 40960 个 CPU，每个 CPU 有 256 个核心。</p> <p>长话短说，这些年处理器不但大大提高了速度，而且也变的更加复杂，用各种技巧榨干每个时钟周期，做尽可能多的运算。我们的任务是利用这些运算能力，做又酷又实用的事情，编程就是为了这个。</p> <h2 id="早期的编程方式"><a href="#早期的编程方式" class="header-anchor">#</a> 早期的编程方式</h2> <p>给机器编程这个需求，在计算机出现之前就有了。最著名的例子来自于纺织业，如果你想织一块红色大桌布，可直接放红线进纺织机；但如果想要图案怎么办？比如条纹或者方格，早期工人需要每隔一段时间，调整一次纺织机，非常消耗体力，所以图案织品很贵。</p> <p>因此，约瑟夫·玛丽·雅卡尔发现了可编程纺织机，1804 年首次亮相，每一行的图案可由穿孔纸卡决定，特定的位置没有穿孔，决定了线是高是低，横线是从上还是从下穿过，为了让每行图案不同，纸卡连成长条，形成连续指令，<a href="https://v.qq.com/x/page/x0553c41d57.html" target="_blank" rel="noopener noreferrer">具体原理看这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。很多人认为雅卡尔织布机是最早的编程.</p> <p>近一个世纪后，打孔卡纸用于美国的人口普查，一张卡片上存一个人的信息，比如种族，婚姻状况等等，针对每个问题，调查员会在对应的位置打孔。当卡片进入汇总机，打孔让对应总数 +1，插整个国家卡片，最后会得到总和。早期的汇总机不算计算机，只用于汇总，操作是固定的，不能编程，打孔卡纸存的是数据，不是程序。之后 60 年，这些机器被加强，可以做加减乘除，甚至可以做一些小决定，决定何时执行某指令。</p> <p><img src="/docs/assets/img/punched_card.e2a526c2.png" alt></p> <p>为了正确执行不同计算，程序员需要某种控制面板，面板上有很多小插孔，程序员可以插电线，让机器的不同部分，互相传数据和信号，因此也叫“插线板”。不幸的是，这意味着，运行不同的程序要重新连线。</p> <p>所以到了 1920 年代，控制面板变成了可拔插，可以让编程更方便，可以给程序插入不同的程序。比如说，一个插线板算销售税，另一个算工资单，但给插线板编程很复杂。用插线板编程，不只在机电计算机流行，世上第一台通用电子计算机，ENIAC，完成于 1946 年，用了一大堆插线板。程序在纸上设计好之后，给 ENIAC 连线，最多可能花三个星期。因为早期计算机非常昂贵，停机几个星期只为换程序完全无法接受。人们急需更快、更灵活的新方式来编程。</p> <p><img src="/docs/assets/img/plug_boards.38b6c74b.png" alt></p> <p>幸运的是，到 1940 年代晚期 1950 年初，内存变得可行，价格下降，容量上升。与其把程序存在插线板，存在内存变的可行，这样程序易于修改、方便 CPU 快速读取。这类机器叫“存储程序计算机”。如果内存足够，不仅可以存要运行的程序，还可以存程序需要的数据，包括程序运行中产生的数据。程序和数据都存在一个地方，叫“冯诺依曼结构”，命名于“约翰·冯·诺依曼”，杰出数学家和物理学家，参与了曼哈顿计划和早期电子计算机项目。</p> <p>冯诺依曼计算机的标志是，一个处理器（有算术逻辑单元）+数据寄存器+指令寄存器+指令地址寄存器+内存（负责存数据和指令），我们前面已经造了一台冯诺依曼计算机。第一台冯诺依曼架构的“存储程序计算机”由曼彻斯特大学于 1948 年建造完成，绰号“宝宝”，甚至你现在看视频的计算机，也在用一样的架构。虽然内存很棒，但程序和数据，依然需要某种方式输入计算机，所以用穿孔卡纸。到 1980 年代，几乎所有的计算机都有穿孔纸卡读取器，可以读取一张卡片，把卡片内容写进内存，如果放了一叠卡片，读取器会一个个写入内存。一旦程序和数据写入完毕，电脑会开始执行。即使简单程序也需要几百条指令，需要很多纸卡，而且不但弄散，需要很多时间整理。穿孔纸卡不仅可以往计算机放数据，还可以取出数据，最终结果输出到纸卡上。然后人可以分析结果，或者再次放入计算机，做进一步计算。</p> <p><img src="/docs/assets/img/punch_cards_reader.d9cbe8a1.png" alt></p> <p>在 1980 年代，出了插线板和穿孔纸卡，还有一种常见编程方式，“面板编程”。与其插一堆线到插线板，可以用一大堆开关和按钮，做到一样的效果。面板上有指示灯，代表各种函数的状态和内存中的值。很少有人用开关来输入一整个程序，但技术上是可行的。早期针对计算机爱好者的家用计算机，大量使用了开关。因为大多数家庭用户负担不起昂贵的外围设备，比如穿孔纸卡读取器。</p> <p><img src="/docs/assets/img/switch_boards.bf0af9db.png" alt></p> <p>第一款取的商业成功的家用计算机是 Altair 8800，有两版可以买：预先装好的整机和需要组装的组件。计算机爱好者喜欢买组件板，售价低。为了给 8800 编程，你要拨动面板上的开关，输入二进制操作码，然后按“存储键”存入内存。然后会到下一个内存位置，你可以再次拨动开关，写入下一个指令。写入正个程序后，可以推动开关，回到内存地址 0，然后按运行按钮，灯会闪烁，这就是 1975 年的家用计算机。</p> <p><img src="/docs/assets/img/8800.8479e6f6.png" alt></p> <p>不论哪种方式，早期编程都是专家活，不论是全职还是技术控，都要非常了解低层硬件，比如操作码，寄存器等，才能写入程序。所以编程很难，我们需要一种更简单的方式告诉计算机做什么，一种更简单的变成方式。</p> <h2 id="编程语言发展史"><a href="#编程语言发展史" class="header-anchor">#</a> 编程语言发展史</h2> <p>之前我们把重点放在了硬件（组成计算机的物理组件），但在硬件层面编程非常麻烦，所以程序员需要一种更通用的方法编程 — 一种更软的媒介。没错，我们要开始说软件。</p> <p>在前面我们一步步讲了一个简单程序，第一条指令在内存地址 0：0010 1110。之前说过，前四位是操作码，简称“OPCODE”。对于这个假设的 CPU，0010 代表 LOAD_A 指令（把值从内存复制到寄存器 A），后四位是内存地址，所以这 8 为表示的意思是“LOAD Address 14 into Register A”。这里用了两种不同的语言，只是编码方式不一样而已，但可以表达相同的信息。计算机能处理二进制，二进制是处理器的“母语”，这叫“机器语言”或“机器码”。</p> <p>在计算机早期阶段，必须用机器码写程序，具体来讲，会先在纸上用英语写一个“高层次版”，被称为“伪代码”（Pseudo-Code）。在纸上写好后，用“操作码表”把伪代码转成二进制机器码，翻译完成后，程序可以喂入计算机并运行，但这种方式，人们很快就厌烦了。</p> <p>所以到 1940-1950 年间，程序员开发出了一种新语言，更可读，更高层次。每个操作码分配一个简单名字，叫“助记符”，助记符后面紧跟数据，形成完整指令。与其用 1 和 0 写代码，程序员可以写“LOAD A 14”。当然，CPU 不知道 LOAD_A 14 是什么，它不能理解文字，只能理解二进制。所以程序员想了一个技巧，写二进制程序来帮忙，它可以读懂文字指令，自动转成二进制指令，这种程序叫“汇编器”（Assembler）。汇编器读取用“汇编语言”写的程序，然后转成“机器码”，“LOAD_A 14”是一个汇编指令的例子。随着时间的推移，汇编器有越来越多的功能，让编程更容易，程序员可以专心编程，不用管低层细节，隐层不必要的细节来做更复杂的工作，我们又提升了一层抽象。</p> <p>然而，虽然汇编器有这些厉害功能，但汇编只是修饰了一下机器码，一般来说，一条汇编指令对应一条机器指令，所以汇编码和低层硬件的链接很紧密。汇编器仍然强迫程序员思考，用什么寄存器和内存地址，如果你突然要一个额外的数，可能要改很多代码。葛丽丝·霍普博士也遇到了这个问题，作为美国海军军官，她是哈佛1号计算机的首批程序员之一，这个我们之前提过。这台巨大的机电野兽在 1944 年战时建造完成，帮助盟军作战，程序写在打孔纸卡上，放进计算机里执行，如果程序里真的有漏洞，真的就直接用胶带补“漏洞”。Mark 1 的指令非常原始，甚至没有 JUMP 指令，如果代码要跑不止一次，得把带子的两端连起来，做成循环，换句话说，要给 Mark 1 编程简直是噩梦。战后，霍普继续在计算机前沿工作，为了释放计算机的潜力，她设计了一个高级编程语言，叫“算术语言版本 0”（Arithmetic Language Version 0），简称“A-0”。汇编与机器指令是一一对应的，但一条高级语言，可能会被转成几十条二进制指令。为了做到这种复杂的转换，Hopper 在 1952 年创造了第一个编译器，编译器专门把高级语言转换成低级语言，比如汇编或机器码。尽管“使编程更简单”很诱人，但很多人对霍普的电子持怀疑态度，她曾说：“我有能用的编译器，但没人愿意用，他们告诉我计算机只能做算术，不能运行程序”。</p> <p>但这个点子是好的，不久很多人尝试创造新的编程语言（如今有上百种语言），可惜的是，没有任何 A-0 的代码遗留下来。所以我们用 Python （一种现代编程语言）举例，假设我们想相加两个数字，保存结果。如果我们用汇编代码，我们得从内存取值，和寄存器打交道，以及其他低层细节。但用 Python 可以这么写：A=3 B=9 C=A+B。不用管寄存器或内存位置，编译器会搞定这些细节，不用管低层细节。程序员只需要创建代表内存地址的抽象，叫“变量”，给变量取名字。现在可以把两个数存在变量里，这里取名 A 和 B，然后相加两个数，把结果存在变量 C。低层操作时，编译器可能把变量 A 存在寄存器 A，但我不需要知道这些。这是个重要的历史里程碑，但 A-0 和之后的版本没有广泛使用。</p> <p><img src="/docs/assets/img/language_compare.e6a1a12b.png" alt></p> <p>FORTRAN，名字来自“公式翻译”（Formula Translation），这门语言数年后由 IBM 在 1957 年发布，主宰了早期计算机编程。项目总监 John Backus 说过：“我做的大部分工作都是因为懒，我不喜欢写程序，所以我写这门语言，让编程更容易”。平均来说，FORTRAN 写的程序比等同的手写汇编代码短 20 倍，然后 FORTRAN 编译器会把代码转成机器码，人们怀疑性能是否比得上手写代码，但因为能让程序员写程序更快，所以成了一个更经济的选择，运行速度慢一点点，编程速度大大提升。</p> <p>当时 IBM 在卖计算机，因此最初 FORTRAN 代码只能跑在 IBM 计算机上，1950 年代大多数编程语言和编译器只能运行在一种计算机上。如果升级电脑，可能要重写所有代码！因此工业界、学术届和政府的计算机专家在 1959 年组件了一个联盟 — 数据系统语言委员会，Grace Hopper 担任顾问，开发一种通用编程语言，可以在不同机器上通用，最后诞生了一门高级，易于使用，“普通面向商业语言”，简称 “COBOL”（Common Business-Oriented Language），为了兼容不同的低层硬件，每个计算机架构需要一个 COBOL 编译器，最重要的是，这些编译器可以接受相同的 COBOL 代码，不管是什么电脑，这叫“一次编写，导出运行”，如今大多数语言都是这样，不必接触 CPU 特有的汇编码和机器码，降低了使用门槛，感谢这些语言，计算机科学从深奥学科，编程了大众化工具，同时，编程抽象也让计算机专家，制作更复杂的程序，如果用汇编可能要上百万行。</p> <p>当然，计算机的历史没有在 1959 年结束，编程语言的黄金时代才刚刚开始，和硬件一起飞速发展。在 1960 年代，有 ALGOL，LISP 和 BASIC 等语言；70 年代有 Pascal，C 和 Smalltalk；80 年代有 C++，Object-C 和 Perl；90 年代有 Python，Ruby 和 Java；新千年 Swift，C#，Go 在崛起。你现在用的浏览器很可能是 C++ 或 Object-C 写的。刚刚说的语言还只是冰山一角，新的编程语言在不断诞生，新语言想用更聪明的抽象，让某些方面更容易或更强大，或利用新技术或新平台带来的优势，让更多人能快速做出美妙的事情。很多人认为编程的“圣杯”是直接用英文，直接对计算机讲话，然后他能理解并执行，这种智能系统目前只存在于科幻小说。现在你了解了编程语言，接下来我们会深入了解用编程语言和用语言写的软件，是怎么做到那么酷的事。</p> <div class="tip custom-block"><p class="custom-block-title">为什么会有这么多编程语言？</p> <p>优秀答案参考<a href="https://www.zhihu.com/question/20104312/answer/15463009" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <h2 id="编程原理-—-语句和函数"><a href="#编程原理-—-语句和函数" class="header-anchor">#</a> 编程原理 — 语句和函数</h2> <p>今天我们讨论，大多数语言都有的基本元素。就像口语一样，编程语言有“语句”（Statements）。语句表达单个完整思想，比如“I want tea”，当然我们也可以换一个词汇表达不同含义，“I want water”，但不能换成“I want raining”，语法毫无意义。规定句子结构的一系列语法叫语句，英语有语法，所有的变成语言也有语法，<code>a=5</code>是一个变成语言语句，意思是创建一个叫 a 的变量，把数字 5 放里面，这叫“赋值语句”，把一个值赋值给一个变量。为了表达更多的含义，需要更多的语句，比如<code>a=5 b=10 c=a+b</code>，注意变量名是可以随意取的，但最好有点意义，方便读懂。</p> <p>程序由一个个指令组成，有点像菜谱：烧水、加面、等10分钟，捞出来就可以吃了。程序也是如此，从第一条语句开始，一句一句运行到结尾。如果我们要做交互式游戏，程序的执行顺序要更灵活，不只是从上到下执行，因此用“控制流语句”（Control Flow Statements），控制流语句有好几种，最常见的是 if 语句，可以想成是“如果 x 为真，那么执行 y”，if 语句就像岔路口，走那条路？取决于“表达式”（Expression）的真假，因此这些表达式又叫“条件语句”（Conditional Statements），这里列了一些热门编程语言 if-then-else 的具体语法，具体语言略有不同，但主题结构一样。</p> <p><img src="/docs/assets/img/if_statement.3bf1feb0.png" alt></p> <p>if 语句根据条件值执行一次，如果希望根据条件执行多次，需要“条件循环”，比如 while 语句，也叫 ”while 循环“（while loop）。当 while 条件为真，代码会重复执行，代码结果大致如下。</p> <p><img src="/docs/assets/img/while_loop.09f875ce.png" alt></p> <p>另一种常见的叫“for 循坏”（For loop）。不判断条件，判断次数，会循环特定次数。</p> <p><img src="/docs/assets/img/for_loop.2a478c99.png" alt></p> <p>在代码中，有些代码会被反复使用到，如果每次使用都复制粘贴，会很麻烦，每次要改变量名，如果代码出现问题修复时，要把每个粘贴的地方都找出来改，而且会让代码很难懂。我们想要某种方法，把代码打包，可以直接使用，得出结果，不用管内部的复杂度，这又提升了一层抽象（a new level of abstraction）。为了隐藏复杂度，可以把代码打包成“函数”（function），有些编程语言也叫“方法”（method）或“子程序”（subroutines）。其他地方想用这个函数，直接写函数名就可以了，如果我们想要把结果返回给使用这个函数的代码，就要用到 return 语句，指明返回什么。函数隐藏了复杂度，能够让我们更多精力放在软件设计上，比如像浏览器这样复杂的程序，用一长串语句来写是不可能的，会有几百万行代码，没人能理解，所以现代软件有上千个函数组成，每个负责不同的事。如今超过100行的代码的函数很少见，如果超过100行，应该有东西可以拆出来做成一个函数。模块化编程（Modularing program）不仅可以让单个程序员独立制作 APP，也让团队协作可以写更大型的程序，不同程序员写不同函数，只需确保自己的代码正常工作，把所有人的拼起来，整个程序也能正常运作。现代编程语言，有很多预先写好的函数集合，叫“库”（Library），由专业人员编写，不仅效率高，而且经过了仔细检查。几乎做所有的事情都有库、网络、图像、声音，之后我们会说道这些。在此之前，我们先讲算法。</p> <h2 id="算法入门"><a href="#算法入门" class="header-anchor">#</a> 算法入门</h2> <p>我们知道实现同一个方法有很多解决方案和不同的算法。不同的“算法”（Algorithm），意思是：解决问题的具体步骤，即使结果一样，有些算法会更好。一般来说，所需的步骤越少越好，不过有时候也会关心其他因素了，比如占多少内存。“算法”一次来自波斯博识者，阿尔·花拉子米，1000多年前的代数已付之一，如何相处高效算法，早在计算机出现之前就有的问题，诞生了专门研究计算的领域，然后发展成了一门现代学科，计算机科学。</p> <p>记在最多的算法是排序（sorting），比如给名字、数字排序等等。排序的算法非常多，还起了各种名字，“冒泡排序”（Bubble Sort）、“意面排序”（Spaghetti Sort）。比如，现在我们一组乱序的数组（数据具体在内存中怎么存储，我们下节再说）。我们先从最简单的一种算法说起：我们从头开始扫描，先找到最小的数字，找到后把它和第一个数字互换位置，就排序好了一个数字；接下来我们从第二个开始，重复上面的步骤，知道全部排序。我们刚刚说的这种算法叫“选择排序”（Selection Sort），一种非常基础的算法，下面是它的伪代码。我们可以看到，如果要排 N 个数字，要循环 N 次，没次循环中再循环 N 次，供 N² 次。 算法的“输入大小”和“运行步骤”之间的关系，叫“算法复杂度”（complexity），表示运行速度的量级。科学家们把算法复杂度叫 — 大 O 表示法。O(N²) 的复杂度十分不高效，随着数组增加，对效率的影响呈指数级增大。</p> <p><img src="/docs/assets/img/select_sort.c7ab815b.png" alt></p> <p>我们来试一下另一种排序算法，“归并排序”（Merge Sort）。第一件事是检查数组大小是否 &gt; 1，如果是，就把数组分成两半，然后继续拆分，直到最后拆分成每项只有一个。然后就可以归并了，“归并排序”的名字由此而来。归并的时候，我们按照大小进行排放，这样每个数组内部是从小到大排好的，我们只需要对两个数组从头开始比较即可。这样问题就转化成了把两个更小的有序数组转换成更大的有序数组。“归并排序”的算法复杂度是 O(n*log n)，n 是需要比较+合并的次数，和数组的大小成正比，<code>log n</code> 是合并步骤的次数，归并排序比选择排序效率更高。排序算法还有很多，这里就不一一去说了。</p> <p>现在我们说一个更经典的算法：图搜索（Graph Search）。图是用线链接起来的一堆节点，可以想成地图，没个节点是一个城市，线是公路。一个城市到另一个城市，花的时间不同，可以用成本（Cost）或权重（Weight）来代称，代表要几个星期。假设要找到“高庭”到“临冬城”的最快路线，最简单的方法是尝试所有的路线，最后进行排序，这种方式的复杂度是 O(n!)，n 是节点数，比 O(n²) 还糟糕。</p> <p><img src="/docs/assets/img/graph_search.7cb9bd2d.png" alt></p> <p>图搜索最经典的算法是理论计算机科学的伟人 Edster Dijkstra，所以也叫“Dijkstra 算法”。从“高庭”开始，此时成本为 0，把 0 标在节点里，其他城市标成问号，因为还不知道成本多少，算法总是从成本最低的节点开始，现在只知道“高庭”，从这里开始，跑到所有相邻节点，记录成本，完成一轮算法，“派克城”（14），“奔流河”（10），“君临城”（8）。还没到临冬城，再跑一次算法，下一个成本最低的节点是“君临城”（8），从这里开始，跟之前一样，记录到相邻节点的成本，到“三叉戟河”的成本是 5，那么从“高庭”到这里的总成本就是 13，另一个支路到“奔流河”，成本 25，总成本是 33，但“奔流河”的最低成本是 10，所以无视。现在还没到“临冬城”，算法继续，下一个成本最低的点是“奔流河”（10），到“三叉戟河”的总成本是 12，比之前的 13 少，所以保留 12，到“派克城”的总成本是 13，比之前 14 少，保留 13，“奔流河”所有路径走完了。还没到，我们再跑一次算法，从总成本低的“三叉戟河”（12）开始，有唯一路，通往“临冬城”，成本是 10，总成本就是 22，再看最后一条路，“派克城”（13）到“临冬城”，总成本 31，现在知道了最低成本路线。“Dijkstra 算法”的初始版本，构思于 1956 年，算法复杂度是 O(n²)，这个效率并不好，幸运的是，算法几年后的得到了改进，复杂度编程了 <code>O(n*log n + l)</code>，n 是节点数，l 代表多少条线。图搜索算法也有很多，有不同的优缺点，打开百度地图搜索地点，类似的“Dijkstra 算法”就会在服务器运行，寻找最佳路线，算法无处不在，现代社会离不开他们。</p> <p><img src="/docs/assets/img/graph_search2.445a9899.png" alt></p> <h2 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h2> <p>上节我们说了算法，但没说算法处理的数据，存在内存中的格式是什么？你肯定不想数据想垃圾堆一样杂乱无章，我们希望数据是结构化的，方便读取，因此计算机科学家发明了“数据结构”。</p> <p>上节我们说到了数组（Array），在其他编程语言里，也有叫列表（List）或向量（Vector）。数组中的值一个个连续存在内存里，不想之前的变量 <code>i=5</code>只存一个值，我们可以把多个值存在数组变量里，通过下标（index）来取出某个值，下标都是从 0 开始的。数组在内存中的方式，十分易懂，假如编译器从内存 1000 开始存数组，数组中有 7 个数组，像下图那样按顺序存。取 j[i]，就会去内存地址 1000，加 i 个偏移，得到地址 1000 + i，拿到对应值。数组的用途和广泛，几乎所有的编程语言，都自带了很多函数去处理数组。</p> <p><img src="/docs/assets/img/array.12219ad1.png" alt></p> <p>数组的亲戚是字符串（String），其实就是字母，数字，标点符号等组成的数组，之前我们讨论过计算机是如何存储字符的。写代码是，用引号括起来就是了 <code>j=&quot;STAN ROCKS&quot;</code>。虽然长的不像数组，但的确是数组，在幕后看起来像下图（注意，字符串在内存中以 0 结尾，不是“字符0”，是“二进制0”，这叫字符“null”，表示字符串结尾），如果调用 print 函数，print 在屏幕中输出字符，会从开始位置，逐个显示到屏幕，到字符串结尾 0 停止。字符串非常常见，也有很多函数专门处理，比如链接字符串的 strcat。</p> <p><img src="/docs/assets/img/string.8f9fbcf9.png" alt></p> <p>我们可以用数组做以为列表，但有时想处理二维列表，比如电子表格，或屏幕中的像素，那么需要矩阵（Matrix），可以把矩阵看成数组的数组，一个 3✖️3 矩阵（<code>j = \{\{10,15,12}, {8,7,42}, {18,12,7\}\}</code>）是一个长度为 3 的数组，里面的每一项都是长度为 3 的数组，内存里是这样排列的(下图)。为了拿到值，需要两个下标，j[1][2]。矩阵不止可以做3✖️3的纬度，任何纬度都可以。</p> <p><img src="/docs/assets/img/matrix.b3044f60.png" alt></p> <p>目前我们只存过单个数字/字符，存进数组或矩阵，但有时，把几个有关系的变量存在一起，会很有用，比如银行账户号和余额，多个变量打包到一起叫“结构体”（Struct）。现在多个不同类型的数据，可以放在一起，甚至可以做一个数组，里面放很多结构体，这些数据在内存里，会自动打包在一起。房、放结构体的数组跟其他数组一样，创建时就有固定大小，不能动态增加大小，还有数组在内存中，按顺序存储，在中间插一个值很困难，但结构体可以创造更复杂的数据结构，消除这些限制。</p> <p><img src="/docs/assets/img/struct.ffa31845.png" alt></p> <p>我们来看一个结构体，叫节点（node），它存一个变量，一个指针（pointer），“指针”是一种特殊变量，指向一个内存地址，因此得名。用节点可以做链表（linked list），链表是一个灵活的数据结构，能存很多个节点，灵活性是通过每个节点指向下一个节点实现的，假设有三个节点，在内存地址 1000，1002，1008，隔开的原因可能是创建时间的不同，可以看到第一个节点，值是 7，指向地址 1008，代表下一个节点位于内存地址 1008，1008 地址值 112，指向 1002，1002 值 14，又指向 1000，这叫循环链表（Circular）。链表也可以不循环，最后一个指针指向 0（“null”），代表链表尽头。链表大小不需要提前预设，可以动态增删，只需要更改指针指向即可。链表很容易重新排序，两端缩减，分割，倒序等。链表也适合上集的排序算法，因为灵活，很多复杂的数据结构都用链表，最出名的是队列（queue）和栈（stack）。</p> <p><img src="/docs/assets/img/linked_list.34b60a0d.png" alt></p> <p>“队列”就像是在邮局排队，谁先来就排在前面，遵循“先进先出”（FIFO）原则（First-in First-out），想象有个指针叫“邮局队列”，指向链表的第一个节点，队首的人服务完之后，读取他的 next 指针，把“邮局队列”指向下一个人，这样第一个人就出队了（dequeue）了；如果我们要把某人入队（enqueue），要遍历整个链表到结尾，然后把结尾的指针指向新人。</p> <p>只要稍作修改，就能用链表做“栈“，栈遵循后进先出（LIFO，Last-in First-in），栈就不叫入队出队了，叫”入栈“（push）和“出栈”（pop）。</p> <p>如果节点改成两个指针，就能做成树，很多算法用了“树”这种数据结构，同样，程序员很少看指针的具体值，而是把“树”抽象成这样：最高的节点叫“根节点”（root），“根节点”下的所有节点叫“子节点”（children），任何子节点的指数上层节点，叫“父节点”（parent node），没有任何“子节点”的节点，也就是“树”结束的地方，叫“叶节点”（leaf）。节点最多只有两个的叫“二叉树”（binary tree）。当然你可以修改随意改成 3 个 4 个...甚至节点可以用链表存所有的子节点。“树”的一个重要性质是（不管现实中还是数据结构中），根到叶是单向的。如果数据随意链接，就可以用“图”（Graph Data）表示，这中结构，可以用有多个指针的节点表示，因此没有根、叶、子节点这些概念。</p> <p>以上我们概述了计算机科学中，最主要的一些数据结构，这些基本结构之上，程序员做了各种新变体，有不同的性质，比如“红黑树”（red-black trees）和“堆”（heaps）。不同的数据结构适用于不同的场景，选择正确的数据结构会让工作更简单，所以花时间考虑用什么数据结构是很重要的。幸运的是，很多编程语言自带了预先做好的数据结构，程序员不用浪费时间从零写，把时间用在更有趣的事情上，又提升了一层抽象.</p> <h2 id="阿兰·图灵"><a href="#阿兰·图灵" class="header-anchor">#</a> 阿兰·图灵</h2> <p>今天我们来看一位对计算机理论贡献巨大的人，计算机科学之父，阿兰·图灵。他对计算机的建树始于 1935 年，当时他是剑桥国王学院的硕士生，他开始解决德国数学家 大卫·希尔伯特 提出的问题，“可判定性问题”（decision problem）：是否存在一种算法，输入正式逻辑语句，输出准确的“是”或“否”答案？如果这样的算法存在，可以回答比如“是否有一个数大于所有数”，没有，我们知道答案。但是有很多其他数学问题，我们想知道答案，所以如果这种算法存在，我们想知道。</p> <p>美国数学家 阿隆佐·丘奇 于 1935 年首次提出解决办法，开发了一个叫“Lambda算子”的数学表达系统，证明了这样的算法不存在，虽然“Lambda算子”能表达任何计算，但它使用的数学技巧，难以理解和使用。同时在大西洋另一边，阿兰·图灵想出来自己的办法来解决“可判定性问题”，提出了一种假象的计算机，现在叫“图灵机”（Turing Machine）。“图灵机”提供了简单又强大的数学计算模型，虽然用的数学不一样，但“图灵机”的计算能力和“Lambda算子”一样，同时因为“图灵机”更简单，在新兴的计算机领域更受欢迎。</p> <p>“图灵机”是一台理论计算设备，有无限长的纸带（纸带可以存储符号），还有一个读写头（可以读取和写入纸带上的符号），还有一个状态变量保存当前状态，还有一组规则，描述机器做什么，规则是根据当前状态+读写头看到的符号，决定机器做什么，规则可能是在纸带写上一个符号，或改变状态，或把读写头移动一格，或执行这些动作的组合。我们来举个简单的例子：让“图灵机”读一个以零结尾的字符串，并计算1的出现次数，是不是偶数，是的话在纸带上写1，否则写0。首先要定义“图灵机”的规则，如果当前状态是“偶数”，当前符号是1，那么把状态更新为“奇数”，把读写头向后移动；如果当前状态是“偶数”，当前符号是0，意味着到了字符串结尾，那么在纸带上写一个1，并且把状态改成停机（halt），状态为停机，说明完成了计算；我们还需要两条规则来处理状态为奇数的情况，一个是当前符号是0时，一个是当前符号是1时；最后，要决定机器的初始状态，这里定成偶数。定义好了初始状态和规则，就像写好了程序，现在可以输入了，假设把“110”放在纸带上，有两个1，是偶数。图灵机准备好，开始吧，看到第一个符号是1，执行对应规则，把状态更新到奇数，读写头向右移动一格，然后又看到1，根据规则状态变回偶数，读写头右移，现在看到0，机器状态是偶数，执行规则在纸带上写1，表示真的有偶数个1，然后机器停机。这就是图灵机的原理，证明了这个简单的假象机器如果有足够的时间和内存，可以执行任何计算，它是一台通用计算机，刚刚的程序就是个简单的例子，只要有足够的规则，状态和纸带，可以创造任何东西，浏览器，魔兽世界都可以，所以图灵机是很强大的计算模型。事实上，就可计算和不可计算而言，没有计算机比图灵机更强大。</p> <p>和图灵机一样强大的，叫“图灵完备”（Turing Complete）。每个现代计算系统，比如电脑手机，甚至微波炉中的内部小电脑，都是图灵完备的。为了回答可判定问题，他把图灵机用于一个有趣的计算问题，停机问题（Halting Problem）：简单来说，给图灵机描述和输入纸带，是否有算法可以确定，机器会永远算下去还是到某一点会停机？即有没有办法在不执行的情况下，弄清会不会停机？有写程序可能要运行好几年，所以在运行前知道会不会出结果很有用。图灵通过一个巧妙的逻辑矛盾证明了停机问题是无法解决的，我们来看看他的推理。</p> <p>想象有一个假象图灵机，输入：问题的描述+纸带的数据，输出 YES 代表会“停机”，输出 No 代表不会，这台机器名字叫 H，不用担心这台机器这么运行，假设这样的机器存在就好，毕竟重点是推论。图灵推理说：如果有个程序，H 无法判定是否会停机，意味着停机问题是无解的。为了找到这个程序，图灵用 H 设计了另一个图灵机，如果 H 说 Yes，即程序会停机，那么新机器户永远运行（不会停机），如果 H 说 No，代表不会停机，那么让新机器输出 No，然后停机。实质上是一台和 H 输出相反的机器，如果程序不停机，就停机，如果程序停机，就永远运行下去。我们还需要在机器前面加一个分离器，让机器只接受一个输入，这个输入既是程序，也是输入。我们把这台新机器叫“异魔”。目前为止，这个机器不难理解，但接下来会变复杂。</p> <p>如果把异魔的描述，做为本身的输入会怎么样？意味着问 H，当异魔的输入是自己时会怎样？但如果 H 说异魔会停机，那么异魔会进入无限循环，因此不会停机。如果 H 说异魔不会停机，那么异魔会输出 No 然后停机。所以 H 不能正确判定停机问题，因此没有答案，这是一个悖论，意味着停机问题不能用图灵机解决。还得得刚刚说：图灵证明了图灵机可以实现任何计算。“停机问题”证明了不是所有问题都能用计算解决。长话短说，丘奇和图灵证明了计算机的能力有限，无论有多少时间和内存，有些问题是计算机无法解决的，丘奇和图灵证明了计算是有极限的，起步了可计算性理论，现在叫“丘奇-图灵论题”</p> <p>图灵的其他事迹<a href="http://open.163.com/newview/movie/free?pid=MDGEPAQ4K&mid=MDGETEB1O" target="_blank" rel="noopener noreferrer">看这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="软件工程"><a href="#软件工程" class="header-anchor">#</a> 软件工程</h2> <p>为了写大型程序，程序员用各种工具和方法，所有的这些形成了“软件工程”学科（Software Engineering）。之前我们说过，把大项目分解成函数，可以让多人同时工作，但像 office 这样庞大的软件有 4000 万行代码，分解成函数也有几十万个，这还是太多了，解决办法就是：把函数打包成层级（hierarchies），把相关代码放在一起，打包成对象（Objects）。把函数打包成对象的思想叫“面向对象编程”（Object Oriented Programming），这种思想和之前抽象相似，通过封装组件，隐藏复杂度。</p> <p>把大型软件分解成小单元更有利于团队合作，各司其职，各尽其能。如果团队间要相互使用，就需要有文档（Documentation）来帮助理解代码都在做什么，以及定义好“程序远程接口”，简称 API（Application Programming Interface）。API 控制哪些函数和数据让外部访问，哪些禁供内部。面向对象编程语言可以指定函数是 public 或 private 来设置权限。面向对象编程的核心是隐藏复杂度，选择性地公布功能，因为做大型项目的时候很有用，广受欢迎。</p> <p>有一点很重要：代码在编译前就只是文字而已，你可以用任何文字处理器处理。但一般来说，现代开发者会有专门的工具来写代码，工具集成了很多功能帮助写代码，整理，测试和编译，因此也叫“集成开发环境”，简称 IDE（Integrated Development Environments），IDE 带了一些非常有用的功能，比如代码高亮，实时检查，整理代码，甚至可以直接编译和运行代码，在你没写完的时候，帮你定位到出错代码，提供有用信息，这叫调试（debug）。</p> <p>除了写代码和调试，程序员工作中还有很大一部分是给代码写文档，文档一般放在一个叫 README 文件中。文档也能写成“注释”（comment），放在源代码中。好文档能够帮助开发者理解自己的代码，对其他人也很重要。文档还可以提高复用性（code reuse），可以与其他人共享代码，而只需要看文档直接用就行。</p> <p>还有一个重要的工具能帮助团队协作，“源代码管理”，也叫“版本控制”（Version Control / Revision Control）。苹果或微软这样的大公司，会把代码放在一个中心服务器上，叫“代码仓库”（code repository），程序员想改一段代码时，可以 check out，就像从图书馆里借书，程序员修改测试通过后，可以把代码放回去，这叫“提交”（commit）。这样程序员可以同时写代码，建立庞大的系统。源代码管理还可以追踪所有变化，如果发现 BUG，我们还可以回滚（rolled back）到之前稳定代码，而且还会记录是谁修改了代码，我们可以追踪到人。</p> <p>写代码一般和代码测试密不可分，测试一般由个人或者小团队完成，测试可以统称“质量保障测试”，简称 QA（Quality Assurance），严格测试软件的方方面面，模拟各种情况寻找问题，简言之找 BUG。</p> <p>你可能听过“beta版”软件，意思是软件接近完成，但不是 100% 测试通过，公司会向公众发布 beta 版，以帮助发现问题。还有一个 beta 之前的版本：alpha 版，alpha 版一般错误很多，经常在公司内部测试。</p> <h2 id="集成电路-摩尔定律"><a href="#集成电路-摩尔定律" class="header-anchor">#</a> 集成电路&amp;摩尔定律</h2> <p>在大概 50 年里，软件从纸带打孔到面向对象编程语言，到集成开发环境中写程序，这些如果没有硬件的大幅度进步，软件是不可能做到这些的。</p> <p>在 1940-1960 年间，计算机基本都由独立部件组成，叫“分立元件”，然后不同组件用线连在一起，如果要提升性能，就要加更多的部件，意味着更多的线，这个叫“数字暴政”（Tyranny of Numbers）。1950 年中期，晶体管开始商业化，开始用于计算机，晶体管比电子管更小更快更可靠，晶体管意味着“计算机2.0时代”到来。但它依然是独立元件，并没有解决数字暴政的问题，有几十万格独立元件的计算机不但难设计而且难生产，计算机里一堆线缠绕在一起，解决办法是引入一层新抽象，封装复杂性。突破性进展在 1958 年，把电路中的元件组装在一起组成一个新的部件，这就是集成电路（IC）。仙童半导体公司的 Noyce 用硅实现集成电路，所以 Noyce 被公认为现代集成电路之父，开窗了电子时代，创造了硅谷。</p> <p>后来工程师们再度创新：印刷电路板（PCB），PCB 可以大规模生产，无需焊接或用一大堆线。它通过刻蚀金属线的方式，把零件连接到一起。把 PCB 和 IC 结合使用，可以大幅减少独立组件和电线，但做到相同的功能。</p> <p>早期 IC 都是把独立元件封装成一个独立单元，不过塞 5 个以上的晶体管还是很困难，为了实现更复杂的设计，“光刻”工艺登场。简单说，就是用光把复图案引到材料上，比如半导体。</p></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">最新更新于: </span> <span class="time">8/26/2020, 11:13:08 PM</span></div></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/docs/cs/algorithm.html">
          常见算法
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/docs/assets/js/app.9c008995.js" defer></script><script src="/docs/assets/js/2.81827272.js" defer></script>
  </body>
</html>
